[{"content":"Forks and join model OpenMP uses forks and join model in which a process splits into multiple threads and then can join back to split again if required.\nExample of OpenMP OpenMP adapts raw OS thread interface to make it more usable.\n# include \u0026lt;omp.h\u0026gt; std::cout \u0026lt;\u0026lt; \u0026#34;Hello single\u0026#34;; #pragma omp parallel { do_work(op_get_thread_num(), omp_get_num_threads()); } gcc -fopenmp filename.c -o exec export OMP_NUM_THREADS=4 () ./exec  omp_get_wtime() gives you system time. It returns a double object.\n It can be used to calculate time taken by the system to execute the program.\nPrivate variables Variable belonging to a specific thread is private variable, while one shared by all the threads is called public variable.\nData Race Hello world #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;omp.h\u0026gt;int main(int argc, char argv[]) { int omp_rank; #pragma omp parallel private(omp_rank)  { omp_rank = omp_get_thread_num(); printf(\u0026#34;Hello world by thread %d\u0026#34;, omp_rank); } } Race condition Two threads when accessing the same variable can result in disparity among the results in multiple executions.\nThe result of the execution depends the\nReductions Summing elements of array is an example of reduction operation.\nReduction is merging the data from multiple threads after the execution is completed.\nOpenMP provides a reduction(operator:var_list)\n!$ OMP PARALLEL DO SHARED(x, y, n) PRIVATE(i) REDUCTION(+:asum) do i = 1, n asum = asum_x(i)*(yi) end do !$OMP END PARALLEL DO Maunally doing the above would look as follows\n!$ OMP PARALLEL DO SHARED(x, y, n, asum) PRIVATE(i, psum) psum = 0.0d !$OMP DO do i = 1, n psum = psum + x(i)*y(i) end do !$ OMP END DO !$ OMP CRITICAL(dosum) asum = asum + psum !$ EMP END CRITICAL(dosum) !OMP END PARALLEL DO This is useful when the operation required to be performed is not supported by the reduction.\nExecution Controls #pragma master Specifies a region that should be executed only by the master thread There is no implicit barrier at the end\n#pragma single Specifies that a regions that should be executed only by a single (arbitrary) thread. Other threads wait until this region is executed.\n#pragma critical [dosum] A section that is executed by only one thread at a time. An optional name specifies different critical sections. Unnamed critical sections are treated as the same section\n#pragma flush [dosum] Synchronies the memory of all threads.\n#pragma atomic No context switch while the region is being executed.\n","permalink":"example.com/posts/hpc/open-mp/","summary":"Forks and join model OpenMP uses forks and join model in which a process splits into multiple threads and then can join back to split again if required.\nExample of OpenMP OpenMP adapts raw OS thread interface to make it more usable.\n# include \u0026lt;omp.h\u0026gt; std::cout \u0026lt;\u0026lt; \u0026#34;Hello single\u0026#34;; #pragma omp parallel { do_work(op_get_thread_num(), omp_get_num_threads()); } gcc -fopenmp filename.c -o exec export OMP_NUM_THREADS=4 () ./exec  omp_get_wtime() gives you system time.","title":"Introduction to OpenMP"},{"content":"Solving large scale problems: (tera-scale / peta-scale) High performance computing can be used to solve problems on a large scale. For eg.\n Getting weather data from a large number of cities and process it to forecast the weather. Predicting the number of active cases at the peak of pandemic or predicting the curve.  Measuring the speed of a processor Process speeds are measured in Gigahertz (hertz = cycles/sec) A average operation in a processor takes several cycles to complete.\n   Unit 10 power 2 power     Kilo 10^3 2^10   Mega 10^6 2^20   GHz 10^9 2^30   THz 10^12 2^40   PHz 10^15 2^50   EHz 10^18 2^60   ZHz 10^21 2^70    How long does it take to solve a linear system? Solving a linear $nxn$ linear system $Ax = b$ takes $(1/3)*n^3$ flops assuming we are using faussian elimination for a dense matrix.\ntherefore for $n=10000$ we need $(1/3)*10^6$ flops.\n","permalink":"example.com/posts/hpc/motivation-for-high-performance-computing/","summary":"Solving large scale problems: (tera-scale / peta-scale) High performance computing can be used to solve problems on a large scale. For eg.\n Getting weather data from a large number of cities and process it to forecast the weather. Predicting the number of active cases at the peak of pandemic or predicting the curve.  Measuring the speed of a processor Process speeds are measured in Gigahertz (hertz = cycles/sec) A average operation in a processor takes several cycles to complete.","title":"Motivation for High Performance Computing"},{"content":"Longest Common Prefix =========================  Description Write a function to find the longest common prefix string amongst an array of strings.\nIf there is no common prefix, return an empty string \u0026ldquo;\u0026rdquo;.\nExample 1: Input: strs = [\u0026quot;flower\u0026quot;,\u0026quot;flow\u0026quot;,\u0026quot;flight\u0026quot;] Output: \u0026quot;fl\u0026quot; Solution Create an iterator integer variable with initial value. Get the letter at the position given by iterator from the first string. For every string there after, if letter changes break out the for loop and while loop.\nclass Solution { public: string longestCommonPrefix(vector\u0026lt;string\u0026gt;\u0026amp; strs) { bool okay = true; int i = 0; prefix = \u0026#34;\u0026#34;; while(okay) { p = strs[0][0]; for (string s: strs) { if (s[0] != p) okay = !okay; break else prefix += p; } } return prefix; } }; ","permalink":"example.com/posts/competitive-coding/14-longest-common-prefix/","summary":"Longest Common Prefix =========================  Description Write a function to find the longest common prefix string amongst an array of strings.\nIf there is no common prefix, return an empty string \u0026ldquo;\u0026rdquo;.\nExample 1: Input: strs = [\u0026quot;flower\u0026quot;,\u0026quot;flow\u0026quot;,\u0026quot;flight\u0026quot;] Output: \u0026quot;fl\u0026quot; Solution Create an iterator integer variable with initial value. Get the letter at the position given by iterator from the first string. For every string there after, if letter changes break out the for loop and while loop.","title":""},{"content":"412. Fizz Buzz Description Given an integer n, return a string array answer (1-indexed) where:\nanswer[i] == \u0026quot;FizzBuzz\u0026quot; if i is divisible by 3 and 5. answer[i] == \u0026quot;Fizz\u0026quot; if i is divisible by 3. answer[i] == \u0026quot;Buzz\u0026quot; if i is divisible by 5. answer[i] == i (as a string) if none of the above conditions are true.\nSolution A straight forward solution with if statements printing out the required word by the appropriate condition.\nclass Solution { public: vector\u0026lt;string\u0026gt; fizzBuzz(int n) { vector\u0026lt;string\u0026gt; out(n); for(int i = 1; i \u0026lt;= n; i++) { string out_str = \u0026#34;\u0026#34;; auto valid = false; if (i % 3 == 0) { out_str += \u0026#34;Fizz\u0026#34;; valid = true; } if (i % 5 == 0) { out_str += \u0026#34;Buzz\u0026#34;; valid = true; } if (valid == false) { out_str += to_string(i); } out[i-1] = out_str; } return(out); } }; Results Runtime: 3 ms, faster than 87.04% of C++ online submissions for Fizz Buzz. Memory Usage: 7.1 MB, less than 96.87% of C++ online submissions for Fizz Buzz.\n","permalink":"example.com/posts/competitive-coding/412-fizz-buzz/","summary":"412. Fizz Buzz Description Given an integer n, return a string array answer (1-indexed) where:\nanswer[i] == \u0026quot;FizzBuzz\u0026quot; if i is divisible by 3 and 5. answer[i] == \u0026quot;Fizz\u0026quot; if i is divisible by 3. answer[i] == \u0026quot;Buzz\u0026quot; if i is divisible by 5. answer[i] == i (as a string) if none of the above conditions are true.\nSolution A straight forward solution with if statements printing out the required word by the appropriate condition.","title":""},{"content":"Network Security  Security of multiple computers Protect data in storage and in transit. Wider field of study than computer security  Cryptographic Communication Transport and exchange protocols Best practices for establishing and maintaining networks   You need to protect not just data but resources  Information security Involves study of mathematical designs of cryptographic, communication transport and exchange protocols.\nEncoding and encrypting algorithms.\nSecuring the computer network  Protect from internal as well as external unauthorised access. Resources are both physical and virtual, Systems can be tangible and non tangible  Tangible Hardware resources\nNon Tangible Information and Data\nSecuring Hardware We protect the user interface hardware like input components.\nNetworks hardware componenent like hubs, switches, routers and gateways which are vulnerable need to be secured.\nNetowrk communication channels to prevent eavesdroppers for intercepting network communications.\nSoftware Protect operating systems and applications, storage devices.\nForms of protection - 5 Pillars of information assuarance  Access control Authentication Confidentiality Integrity Non repudiation  ","permalink":"example.com/posts/ncs/ncs/","summary":"Network Security  Security of multiple computers Protect data in storage and in transit. Wider field of study than computer security  Cryptographic Communication Transport and exchange protocols Best practices for establishing and maintaining networks   You need to protect not just data but resources  Information security Involves study of mathematical designs of cryptographic, communication transport and exchange protocols.\nEncoding and encrypting algorithms.\nSecuring the computer network  Protect from internal as well as external unauthorised access.","title":""}]